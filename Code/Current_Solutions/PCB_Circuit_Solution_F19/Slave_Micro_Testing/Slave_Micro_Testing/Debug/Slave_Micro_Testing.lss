
Slave_Micro_Testing.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800100  0000077c  00000810  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000077c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000b  00800112  00800112  00000822  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000822  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000854  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000220  00000000  00000000  00000890  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002d27  00000000  00000000  00000ab0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000111c  00000000  00000000  000037d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000011dc  00000000  00000000  000048f3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000007f0  00000000  00000000  00005ad0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000d36  00000000  00000000  000062c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000027f2  00000000  00000000  00006ff6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000238  00000000  00000000  000097e8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	21 c0       	rjmp	.+66     	; 0x44 <__ctors_end>
   2:	3b c0       	rjmp	.+118    	; 0x7a <__bad_interrupt>
   4:	3a c0       	rjmp	.+116    	; 0x7a <__bad_interrupt>
   6:	39 c0       	rjmp	.+114    	; 0x7a <__bad_interrupt>
   8:	38 c0       	rjmp	.+112    	; 0x7a <__bad_interrupt>
   a:	37 c0       	rjmp	.+110    	; 0x7a <__bad_interrupt>
   c:	36 c0       	rjmp	.+108    	; 0x7a <__bad_interrupt>
   e:	35 c0       	rjmp	.+106    	; 0x7a <__bad_interrupt>
  10:	34 c0       	rjmp	.+104    	; 0x7a <__bad_interrupt>
  12:	33 c0       	rjmp	.+102    	; 0x7a <__bad_interrupt>
  14:	32 c0       	rjmp	.+100    	; 0x7a <__bad_interrupt>
  16:	29 c1       	rjmp	.+594    	; 0x26a <__vector_11>
  18:	30 c0       	rjmp	.+96     	; 0x7a <__bad_interrupt>
  1a:	2f c0       	rjmp	.+94     	; 0x7a <__bad_interrupt>
  1c:	2e c0       	rjmp	.+92     	; 0x7a <__bad_interrupt>
  1e:	2d c0       	rjmp	.+90     	; 0x7a <__bad_interrupt>
  20:	2c c0       	rjmp	.+88     	; 0x7a <__bad_interrupt>
  22:	80 c1       	rjmp	.+768    	; 0x324 <__vector_17>
  24:	2a c0       	rjmp	.+84     	; 0x7a <__bad_interrupt>
  26:	29 c0       	rjmp	.+82     	; 0x7a <__bad_interrupt>
  28:	28 c0       	rjmp	.+80     	; 0x7a <__bad_interrupt>
  2a:	27 c0       	rjmp	.+78     	; 0x7a <__bad_interrupt>
  2c:	26 c0       	rjmp	.+76     	; 0x7a <__bad_interrupt>
  2e:	25 c0       	rjmp	.+74     	; 0x7a <__bad_interrupt>
  30:	24 c0       	rjmp	.+72     	; 0x7a <__bad_interrupt>
  32:	23 c0       	rjmp	.+70     	; 0x7a <__bad_interrupt>
  34:	2a c0       	rjmp	.+84     	; 0x8a <readADC+0xe>
  36:	2c c0       	rjmp	.+88     	; 0x90 <readADC+0x14>
  38:	2f c0       	rjmp	.+94     	; 0x98 <readADC+0x1c>
  3a:	32 c0       	rjmp	.+100    	; 0xa0 <readADC+0x24>
  3c:	35 c0       	rjmp	.+106    	; 0xa8 <readADC+0x2c>
  3e:	38 c0       	rjmp	.+112    	; 0xb0 <readADC+0x34>
  40:	3b c0       	rjmp	.+118    	; 0xb8 <readADC+0x3c>
  42:	3e c0       	rjmp	.+124    	; 0xc0 <readADC+0x44>

00000044 <__ctors_end>:
  44:	11 24       	eor	r1, r1
  46:	1f be       	out	0x3f, r1	; 63
  48:	cf ef       	ldi	r28, 0xFF	; 255
  4a:	d4 e0       	ldi	r29, 0x04	; 4
  4c:	de bf       	out	0x3e, r29	; 62
  4e:	cd bf       	out	0x3d, r28	; 61

00000050 <__do_copy_data>:
  50:	11 e0       	ldi	r17, 0x01	; 1
  52:	a0 e0       	ldi	r26, 0x00	; 0
  54:	b1 e0       	ldi	r27, 0x01	; 1
  56:	ec e7       	ldi	r30, 0x7C	; 124
  58:	f7 e0       	ldi	r31, 0x07	; 7
  5a:	02 c0       	rjmp	.+4      	; 0x60 <__do_copy_data+0x10>
  5c:	05 90       	lpm	r0, Z+
  5e:	0d 92       	st	X+, r0
  60:	a2 31       	cpi	r26, 0x12	; 18
  62:	b1 07       	cpc	r27, r17
  64:	d9 f7       	brne	.-10     	; 0x5c <__do_copy_data+0xc>

00000066 <__do_clear_bss>:
  66:	21 e0       	ldi	r18, 0x01	; 1
  68:	a2 e1       	ldi	r26, 0x12	; 18
  6a:	b1 e0       	ldi	r27, 0x01	; 1
  6c:	01 c0       	rjmp	.+2      	; 0x70 <.do_clear_bss_start>

0000006e <.do_clear_bss_loop>:
  6e:	1d 92       	st	X+, r1

00000070 <.do_clear_bss_start>:
  70:	ad 31       	cpi	r26, 0x1D	; 29
  72:	b2 07       	cpc	r27, r18
  74:	e1 f7       	brne	.-8      	; 0x6e <.do_clear_bss_loop>
  76:	f7 d0       	rcall	.+494    	; 0x266 <main>
  78:	7f c3       	rjmp	.+1790   	; 0x778 <_exit>

0000007a <__bad_interrupt>:
  7a:	c2 cf       	rjmp	.-124    	; 0x0 <__vectors>

0000007c <readADC>:

//Implement a function to read from an ADC channel.
unsigned int readADC( unsigned int channel_num )
{
	//Determine the correct bit pattern to send to the ADMUX register based on the desired channel number.
	switch ( channel_num )
  7c:	88 30       	cpi	r24, 0x08	; 8
  7e:	91 05       	cpc	r25, r1
  80:	10 f5       	brcc	.+68     	; 0xc6 <readADC+0x4a>
  82:	fc 01       	movw	r30, r24
  84:	e6 5e       	subi	r30, 0xE6	; 230
  86:	ff 4f       	sbci	r31, 0xFF	; 255
  88:	09 94       	ijmp
	{
	case 0 :
		ADMUX  = 0b00000000;
  8a:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__EEPROM_REGION_LENGTH__+0x7f007c>
		break;
  8e:	1b c0       	rjmp	.+54     	; 0xc6 <readADC+0x4a>
	case 1 :
		ADMUX  = 0b00000001;
  90:	81 e0       	ldi	r24, 0x01	; 1
  92:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__EEPROM_REGION_LENGTH__+0x7f007c>
		break;
  96:	17 c0       	rjmp	.+46     	; 0xc6 <readADC+0x4a>
	case 2 :
		ADMUX  = 0b00000010;
  98:	82 e0       	ldi	r24, 0x02	; 2
  9a:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__EEPROM_REGION_LENGTH__+0x7f007c>
		break;
  9e:	13 c0       	rjmp	.+38     	; 0xc6 <readADC+0x4a>
	case 3 :
		ADMUX  = 0b00000011;
  a0:	83 e0       	ldi	r24, 0x03	; 3
  a2:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__EEPROM_REGION_LENGTH__+0x7f007c>
		break;
  a6:	0f c0       	rjmp	.+30     	; 0xc6 <readADC+0x4a>
	case 4 :
		ADMUX  = 0b00000100;	
  a8:	84 e0       	ldi	r24, 0x04	; 4
  aa:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__EEPROM_REGION_LENGTH__+0x7f007c>
		break;
  ae:	0b c0       	rjmp	.+22     	; 0xc6 <readADC+0x4a>
	case 5 :
		ADMUX  = 0b00000101;
  b0:	85 e0       	ldi	r24, 0x05	; 5
  b2:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__EEPROM_REGION_LENGTH__+0x7f007c>
		break;
  b6:	07 c0       	rjmp	.+14     	; 0xc6 <readADC+0x4a>
	case 6 :
		ADMUX  = 0b00000110;	
  b8:	86 e0       	ldi	r24, 0x06	; 6
  ba:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__EEPROM_REGION_LENGTH__+0x7f007c>
		break;
  be:	03 c0       	rjmp	.+6      	; 0xc6 <readADC+0x4a>
	case 7 :
		ADMUX  = 0b00000111;	
  c0:	87 e0       	ldi	r24, 0x07	; 7
  c2:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__EEPROM_REGION_LENGTH__+0x7f007c>
		break;
	}
	
	//Retrieve the current ADC value at the specified channel.
	ADCSRA = ADCSRA | 0b01000000;						// Start AD conversion.  Sets bit 7 to 1 and leaves all other bits the same.
  c6:	ea e7       	ldi	r30, 0x7A	; 122
  c8:	f0 e0       	ldi	r31, 0x00	; 0
  ca:	80 81       	ld	r24, Z
  cc:	80 64       	ori	r24, 0x40	; 64
  ce:	80 83       	st	Z, r24
	while ((ADCSRA & 0b01000000) == 0b01000000);		// Wait while AD conversion is executed.  Waits until bit 7 is set to 1.
  d0:	80 81       	ld	r24, Z
  d2:	86 fd       	sbrc	r24, 6
  d4:	fd cf       	rjmp	.-6      	; 0xd0 <readADC+0x54>
	return ADCW;										// [0-1023] ADC value.
  d6:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__EEPROM_REGION_LENGTH__+0x7f0078>
  da:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__EEPROM_REGION_LENGTH__+0x7f0079>
	
}
  de:	08 95       	ret

000000e0 <bang_bang_pressure_control>:
}


// Implement a function that controls the pressure in the BPA using a bang-bang control technique with a threshold.
void bang_bang_pressure_control( float p_desired, float p_actual )
{
  e0:	4f 92       	push	r4
  e2:	5f 92       	push	r5
  e4:	6f 92       	push	r6
  e6:	7f 92       	push	r7
  e8:	8f 92       	push	r8
  ea:	9f 92       	push	r9
  ec:	af 92       	push	r10
  ee:	bf 92       	push	r11
  f0:	cf 92       	push	r12
  f2:	df 92       	push	r13
  f4:	ef 92       	push	r14
  f6:	ff 92       	push	r15
  f8:	4b 01       	movw	r8, r22
  fa:	5c 01       	movw	r10, r24
  fc:	69 01       	movw	r12, r18
  fe:	7a 01       	movw	r14, r20
	// Define local variables.
	float p_lower;
	float p_upper;
	
	// Compute the lower and upper pressure bounds.
	p_lower = p_desired - p_threshold;
 100:	40 90 0e 01 	lds	r4, 0x010E	; 0x80010e <p_threshold>
 104:	50 90 0f 01 	lds	r5, 0x010F	; 0x80010f <p_threshold+0x1>
 108:	60 90 10 01 	lds	r6, 0x0110	; 0x800110 <p_threshold+0x2>
 10c:	70 90 11 01 	lds	r7, 0x0111	; 0x800111 <p_threshold+0x3>
	p_upper = p_desired + p_threshold;

	// Determine whether to open or close the valve.
	if (p_actual > p_upper)				// If the current pressure is above the upper pressure limit...
 110:	9b 01       	movw	r18, r22
 112:	ac 01       	movw	r20, r24
 114:	c3 01       	movw	r24, r6
 116:	b2 01       	movw	r22, r4
 118:	39 d1       	rcall	.+626    	; 0x38c <__addsf3>
 11a:	a7 01       	movw	r20, r14
 11c:	96 01       	movw	r18, r12
 11e:	9a d1       	rcall	.+820    	; 0x454 <__cmpsf2>
 120:	88 23       	and	r24, r24
 122:	14 f4       	brge	.+4      	; 0x128 <bang_bang_pressure_control+0x48>
	{
		// Close the valve to exhaust air.
		PORTB &= ~(1 << 1);
 124:	29 98       	cbi	0x05, 1	; 5
 126:	0b c0       	rjmp	.+22     	; 0x13e <bang_bang_pressure_control+0x5e>
	}
	else if (p_actual < p_lower)		// If the current pressure is below the lower pressure limit...
 128:	a3 01       	movw	r20, r6
 12a:	92 01       	movw	r18, r4
 12c:	c5 01       	movw	r24, r10
 12e:	b4 01       	movw	r22, r8
 130:	2c d1       	rcall	.+600    	; 0x38a <__subsf3>
 132:	a7 01       	movw	r20, r14
 134:	96 01       	movw	r18, r12
 136:	99 d2       	rcall	.+1330   	; 0x66a <__gesf2>
 138:	18 16       	cp	r1, r24
 13a:	0c f4       	brge	.+2      	; 0x13e <bang_bang_pressure_control+0x5e>
	{
		// Open the valve to add air.
		PORTB |= (1 << 1);
 13c:	29 9a       	sbi	0x05, 1	; 5
	}
	
}
 13e:	ff 90       	pop	r15
 140:	ef 90       	pop	r14
 142:	df 90       	pop	r13
 144:	cf 90       	pop	r12
 146:	bf 90       	pop	r11
 148:	af 90       	pop	r10
 14a:	9f 90       	pop	r9
 14c:	8f 90       	pop	r8
 14e:	7f 90       	pop	r7
 150:	6f 90       	pop	r6
 152:	5f 90       	pop	r5
 154:	4f 90       	pop	r4
 156:	08 95       	ret

00000158 <byte_array2int>:
	ADCuint16 = round( (65535/1023)*ADC_value );

	//Return the uint16 value associated with the ADC value.
	return ADCuint16;
	
}
 158:	cf 93       	push	r28
 15a:	df 93       	push	r29
 15c:	00 d0       	rcall	.+0      	; 0x15e <byte_array2int+0x6>
 15e:	cd b7       	in	r28, 0x3d	; 61
 160:	de b7       	in	r29, 0x3e	; 62
 162:	fc 01       	movw	r30, r24
 164:	20 81       	ld	r18, Z
 166:	29 83       	std	Y+1, r18	; 0x01
 168:	81 81       	ldd	r24, Z+1	; 0x01
 16a:	8a 83       	std	Y+2, r24	; 0x02
 16c:	89 81       	ldd	r24, Y+1	; 0x01
 16e:	9a 81       	ldd	r25, Y+2	; 0x02
 170:	0f 90       	pop	r0
 172:	0f 90       	pop	r0
 174:	df 91       	pop	r29
 176:	cf 91       	pop	r28
 178:	08 95       	ret

0000017a <int2byte_array>:
 17a:	cf 93       	push	r28
 17c:	df 93       	push	r29
 17e:	00 d0       	rcall	.+0      	; 0x180 <int2byte_array+0x6>
 180:	cd b7       	in	r28, 0x3d	; 61
 182:	de b7       	in	r29, 0x3e	; 62
 184:	9a 83       	std	Y+2, r25	; 0x02
 186:	89 83       	std	Y+1, r24	; 0x01
 188:	fb 01       	movw	r30, r22
 18a:	80 83       	st	Z, r24
 18c:	8a 81       	ldd	r24, Y+2	; 0x02
 18e:	81 83       	std	Z+1, r24	; 0x01
 190:	0f 90       	pop	r0
 192:	0f 90       	pop	r0
 194:	df 91       	pop	r29
 196:	cf 91       	pop	r28
 198:	08 95       	ret

0000019a <uint162ADC>:
	
	// Define a variable to store the ADC value.
	unsigned int ADC_value;
	
	// Convert the uint16 to an ADC value.
	ADC_value = round( (1023./65535.)*uint16_value );
 19a:	bc 01       	movw	r22, r24
 19c:	80 e0       	ldi	r24, 0x00	; 0
 19e:	90 e0       	ldi	r25, 0x00	; 0
 1a0:	89 d1       	rcall	.+786    	; 0x4b4 <__floatunsisf>
 1a2:	20 e0       	ldi	r18, 0x00	; 0
 1a4:	31 ec       	ldi	r19, 0xC1	; 193
 1a6:	4f e7       	ldi	r20, 0x7F	; 127
 1a8:	5c e3       	ldi	r21, 0x3C	; 60
 1aa:	63 d2       	rcall	.+1222   	; 0x672 <__mulsf3>
 1ac:	c5 d2       	rcall	.+1418   	; 0x738 <round>
	
	// Return the ADC value.
	return ADC_value;
 1ae:	56 d1       	rcall	.+684    	; 0x45c <__fixunssfsi>
	
}
 1b0:	cb 01       	movw	r24, r22
 1b2:	08 95       	ret

000001b4 <ADC2Voltage>:
	// Convert the ADC value to a voltage.
	//voltage = (5./1023)*ADC_value;
	voltage = (4.3/1023)*ADC_value;

	// Return the voltage.
	return voltage;
 1b4:	bc 01       	movw	r22, r24
 1b6:	80 e0       	ldi	r24, 0x00	; 0
 1b8:	90 e0       	ldi	r25, 0x00	; 0
 1ba:	7c d1       	rcall	.+760    	; 0x4b4 <__floatunsisf>
 1bc:	29 e0       	ldi	r18, 0x09	; 9
 1be:	3c eb       	ldi	r19, 0xBC	; 188
 1c0:	49 e8       	ldi	r20, 0x89	; 137
 1c2:	5b e3       	ldi	r21, 0x3B	; 59
 1c4:	56 d2       	rcall	.+1196   	; 0x672 <__mulsf3>
	
}
 1c6:	08 95       	ret

000001c8 <uart_putchar>:
//Include the associated header file.
#include "Slave_Micro_Testing_Header.h"

//Implement the USART putchar function.
void uart_putchar(char c, FILE *stream)
{
 1c8:	cf 93       	push	r28
 1ca:	c8 2f       	mov	r28, r24
	if (c == '\n') uart_putchar('\r', stream);
 1cc:	8a 30       	cpi	r24, 0x0A	; 10
 1ce:	11 f4       	brne	.+4      	; 0x1d4 <uart_putchar+0xc>
 1d0:	8d e0       	ldi	r24, 0x0D	; 13
 1d2:	fa df       	rcall	.-12     	; 0x1c8 <uart_putchar>
	
	loop_until_bit_is_set(UCSR0A, UDRE0);
 1d4:	e0 ec       	ldi	r30, 0xC0	; 192
 1d6:	f0 e0       	ldi	r31, 0x00	; 0
 1d8:	80 81       	ld	r24, Z
 1da:	85 ff       	sbrs	r24, 5
 1dc:	fd cf       	rjmp	.-6      	; 0x1d8 <uart_putchar+0x10>
	UDR0 = c;
 1de:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__EEPROM_REGION_LENGTH__+0x7f00c6>
}
 1e2:	cf 91       	pop	r28
 1e4:	08 95       	ret

000001e6 <SetupPins>:

//Implement a function to setup ADC.
void SetupADC( void )
{
	//Setup the ADC.
	ADCSRA = 0b10000111;	//ADC on, /128 for a 16 MHz clock, interrupt off.		
 1e6:	83 e1       	ldi	r24, 0x13	; 19
 1e8:	84 b9       	out	0x04, r24	; 4
 1ea:	17 b8       	out	0x07, r1	; 7
 1ec:	8e ef       	ldi	r24, 0xFE	; 254
 1ee:	8a b9       	out	0x0a, r24	; 10
 1f0:	28 98       	cbi	0x05, 0	; 5
 1f2:	29 98       	cbi	0x05, 1	; 5
 1f4:	2c 98       	cbi	0x05, 4	; 5
 1f6:	5a 98       	cbi	0x0b, 2	; 11
 1f8:	5b 98       	cbi	0x0b, 3	; 11
 1fa:	5c 98       	cbi	0x0b, 4	; 11
 1fc:	5d 98       	cbi	0x0b, 5	; 11
 1fe:	5e 98       	cbi	0x0b, 6	; 11
 200:	5f 98       	cbi	0x0b, 7	; 11
 202:	08 95       	ret

00000204 <SetupSPI>:
	//Define local variables.
	unsigned char temp;
	
	//Configure the SPI Control Register (SPCR).
	//SPCR=0b01000010;			//0, 1 = SPI Clock Rate Setting (SPR0, SPR1); 2 = SPI Clock Phase (CPHA); 3 = SPI Clock Polarity (CPOL); 4 = Master / Slave Setting (MSTR); 5 = SPI Data Order (DORD); 6 = SPI Enable (SPE); 7 = SPI Interrupt Enable (SPIE)
	SPCR=0b11000010;			//0, 1 = SPI Clock Rate Setting (SPR0, SPR1); 2 = SPI Clock Phase (CPHA); 3 = SPI Clock Polarity (CPOL); 4 = Master / Slave Setting (MSTR); 5 = SPI Data Order (DORD); 6 = SPI Enable (SPE); 7 = SPI Interrupt Enable (SPIE)
 204:	82 ec       	ldi	r24, 0xC2	; 194
 206:	8c bd       	out	0x2c, r24	; 44
	
	//Clear the SPI Status Register (SPSR) and SPI Data Register (SPDR) by reading them.
	temp = SPSR;
 208:	8d b5       	in	r24, 0x2d	; 45
	temp = SPDR;
 20a:	8e b5       	in	r24, 0x2e	; 46
 20c:	08 95       	ret

0000020e <SetupTimerInterrupts>:

//Implement a function to setup timer interrupts.
void SetupTimerInterrupts( void )
{
	//Setup timer interrupt properties.
	TCCR1B |= (1 << WGM12);										// Configure timer 1 for CTC mode
 20e:	e1 e8       	ldi	r30, 0x81	; 129
 210:	f0 e0       	ldi	r31, 0x00	; 0
 212:	80 81       	ld	r24, Z
 214:	88 60       	ori	r24, 0x08	; 8
 216:	80 83       	st	Z, r24
	TIMSK1 |= (1 << OCIE1A);									// Enable CTC interrupt
 218:	af e6       	ldi	r26, 0x6F	; 111
 21a:	b0 e0       	ldi	r27, 0x00	; 0
 21c:	8c 91       	ld	r24, X
 21e:	82 60       	ori	r24, 0x02	; 2
 220:	8c 93       	st	X, r24
	OCR1A = 15999;												//Set target timer count for 1 kHz interrupt given 16MHz clock & prescaler of 1. Use 3999 for 4 kHz under same conditions. OCR1A = Target_Timer_Count = (Clock_Frequency / (Prescale * Target_Frequency)) – 1
 222:	8f e7       	ldi	r24, 0x7F	; 127
 224:	9e e3       	ldi	r25, 0x3E	; 62
 226:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__EEPROM_REGION_LENGTH__+0x7f0089>
 22a:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__EEPROM_REGION_LENGTH__+0x7f0088>
	TCCR1B |= ((1 << CS10) | (0 << CS11) | (0 << CS12));		//Sets the prescaler to 1.
 22e:	80 81       	ld	r24, Z
 230:	81 60       	ori	r24, 0x01	; 1
 232:	80 83       	st	Z, r24
 234:	08 95       	ret

00000236 <SetupUSART>:

//Implement a function to setup USART communication.
void SetupUSART( void )
{
	//USART Setup
	UBRR0H = MYUBRR >> 8;
 236:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__EEPROM_REGION_LENGTH__+0x7f00c5>
	UBRR0L = MYUBRR;
 23a:	80 e1       	ldi	r24, 0x10	; 16
 23c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__EEPROM_REGION_LENGTH__+0x7f00c4>
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
 240:	88 e1       	ldi	r24, 0x18	; 24
 242:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__EEPROM_REGION_LENGTH__+0x7f00c1>
	stdout = &mystdout;
 246:	80 e0       	ldi	r24, 0x00	; 0
 248:	91 e0       	ldi	r25, 0x01	; 1
 24a:	90 93 1a 01 	sts	0x011A, r25	; 0x80011a <__iob+0x3>
 24e:	80 93 19 01 	sts	0x0119, r24	; 0x800119 <__iob+0x2>
 252:	08 95       	ret

00000254 <SetupMicro>:
//Implement a function to setup mircocontroller functionality.
void SetupMicro( void )
{
	
	//Setup the microcontroller pins.
	SetupPins();
 254:	c8 df       	rcall	.-112    	; 0x1e6 <SetupPins>

//Implement a function to setup ADC.
void SetupADC( void )
{
	//Setup the ADC.
	ADCSRA = 0b10000111;	//ADC on, /128 for a 16 MHz clock, interrupt off.		
 256:	87 e8       	ldi	r24, 0x87	; 135
 258:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__EEPROM_REGION_LENGTH__+0x7f007a>
	
	//Setup for ADC.
	SetupADC();
	
	//Setup SPI communication.
	SetupSPI();
 25c:	d3 df       	rcall	.-90     	; 0x204 <SetupSPI>
	
	//Setup timer interrupts.
	SetupTimerInterrupts();
 25e:	d7 df       	rcall	.-82     	; 0x20e <SetupTimerInterrupts>
	
	//Setup USART communication.
	SetupUSART();	
 260:	ea df       	rcall	.-44     	; 0x236 <SetupUSART>
	
	//Enable global interrupts.
	sei();													// Enable global interrupts
 262:	78 94       	sei
 264:	08 95       	ret

00000266 <main>:
//Implement the main function.
int main (void)
{
	
	//Setup the microcontroller.
	SetupMicro();
 266:	f6 df       	rcall	.-20     	; 0x254 <SetupMicro>
 268:	ff cf       	rjmp	.-2      	; 0x268 <main+0x2>

0000026a <__vector_11>:

}

//Implement the first timer interrupt function.
ISR(TIMER1_COMPA_vect)
{			
 26a:	1f 92       	push	r1
 26c:	0f 92       	push	r0
 26e:	0f b6       	in	r0, 0x3f	; 63
 270:	0f 92       	push	r0
 272:	11 24       	eor	r1, r1
 274:	cf 92       	push	r12
 276:	df 92       	push	r13
 278:	ef 92       	push	r14
 27a:	ff 92       	push	r15
 27c:	0f 93       	push	r16
 27e:	1f 93       	push	r17
 280:	2f 93       	push	r18
 282:	3f 93       	push	r19
 284:	4f 93       	push	r20
 286:	5f 93       	push	r21
 288:	6f 93       	push	r22
 28a:	7f 93       	push	r23
 28c:	8f 93       	push	r24
 28e:	9f 93       	push	r25
 290:	af 93       	push	r26
 292:	bf 93       	push	r27
 294:	ef 93       	push	r30
 296:	ff 93       	push	r31
 298:	cf 93       	push	r28
 29a:	df 93       	push	r29
 29c:	00 d0       	rcall	.+0      	; 0x29e <__vector_11+0x34>
 29e:	cd b7       	in	r28, 0x3d	; 61
 2a0:	de b7       	in	r29, 0x3e	; 62
	float p_actual;
	uint16_t p_actual_int;
	unsigned char p_actual_bytes[2];
	
	// Retrieve the desired pressure value from the SPI bytes.
	p_desired = ADC2Voltage( uint162ADC( byte_array2int( spi_bytes ) ) );						// [0-4.3] Desired pressure as a floating point voltage.
 2a2:	85 e1       	ldi	r24, 0x15	; 21
 2a4:	91 e0       	ldi	r25, 0x01	; 1
 2a6:	58 df       	rcall	.-336    	; 0x158 <byte_array2int>
 2a8:	78 df       	rcall	.-272    	; 0x19a <uint162ADC>
 2aa:	84 df       	rcall	.-248    	; 0x1b4 <ADC2Voltage>
 2ac:	6b 01       	movw	r12, r22
 2ae:	7c 01       	movw	r14, r24
		
	//p_desired = 2.5;
		
	// Read in the current pressure value integer.
	//p_actual = ADC2Voltage( readADC( 0 ) );													// [0-4.3] Actual pressure as a floating point voltage.
	p_actual_int = readADC( 0 );																// [0-1023] Actual pressure as a uint16_t.
 2b0:	80 e0       	ldi	r24, 0x00	; 0
 2b2:	90 e0       	ldi	r25, 0x00	; 0
 2b4:	e3 de       	rcall	.-570    	; 0x7c <readADC>
 2b6:	8c 01       	movw	r16, r24
	
	// Convert the current pressure integer into its constitute byte array.
	int2byte_array( p_actual_int, p_actual_bytes );
 2b8:	be 01       	movw	r22, r28
 2ba:	6f 5f       	subi	r22, 0xFF	; 255
 2bc:	7f 4f       	sbci	r23, 0xFF	; 255
 2be:	5d df       	rcall	.-326    	; 0x17a <int2byte_array>
	
	// Determine whether we finished sending the last spi byte array to the master.
	if (spi_index == 0)							// If we finished sending the last spi byte array to the master...
 2c0:	80 91 12 01 	lds	r24, 0x0112	; 0x800112 <__data_end>
 2c4:	81 11       	cpse	r24, r1
 2c6:	08 c0       	rjmp	.+16     	; 0x2d8 <__vector_11+0x6e>
	{
	
		// Store the current pressure byte array into the spi bytes to send array.
		spi_bytes_to_send[0] = p_actual_bytes[0];
 2c8:	89 81       	ldd	r24, Y+1	; 0x01
 2ca:	e3 e1       	ldi	r30, 0x13	; 19
 2cc:	f1 e0       	ldi	r31, 0x01	; 1
 2ce:	80 83       	st	Z, r24
		spi_bytes_to_send[1] = p_actual_bytes[1];
 2d0:	8a 81       	ldd	r24, Y+2	; 0x02
 2d2:	81 83       	std	Z+1, r24	; 0x01
		
		// Load the spi data register with the first byte of the new array to send.
		SPDR = spi_bytes_to_send[0];
 2d4:	80 81       	ld	r24, Z
 2d6:	8e bd       	out	0x2e, r24	; 46
		
	}

	// Convert the current pressure ADC integer to a voltage.
	p_actual = ADC2Voltage( p_actual_int );														// [0-4.3] Actual pressure as a floating point voltage.
 2d8:	c8 01       	movw	r24, r16
 2da:	6c df       	rcall	.-296    	; 0x1b4 <ADC2Voltage>
 2dc:	9b 01       	movw	r18, r22
 2de:	ac 01       	movw	r20, r24

		
	// Perform bang-bang control.  i.e., if the actual pressure is sufficiently far below the desired pressure, open the valve to increase the pressure.  If the actual pressure is sufficiently far above the actual pressure, close the valve to decrease the pressure.
	bang_bang_pressure_control( p_desired, p_actual );
 2e0:	c7 01       	movw	r24, r14
 2e2:	b6 01       	movw	r22, r12
 2e4:	fd de       	rcall	.-518    	; 0xe0 <bang_bang_pressure_control>
	
	
	// Toggle a pin each time this interrupt executes.
	PORTD ^= (1 << 3);
 2e6:	9b b1       	in	r25, 0x0b	; 11
 2e8:	88 e0       	ldi	r24, 0x08	; 8
 2ea:	89 27       	eor	r24, r25
 2ec:	8b b9       	out	0x0b, r24	; 11
	
}
 2ee:	0f 90       	pop	r0
 2f0:	0f 90       	pop	r0
 2f2:	df 91       	pop	r29
 2f4:	cf 91       	pop	r28
 2f6:	ff 91       	pop	r31
 2f8:	ef 91       	pop	r30
 2fa:	bf 91       	pop	r27
 2fc:	af 91       	pop	r26
 2fe:	9f 91       	pop	r25
 300:	8f 91       	pop	r24
 302:	7f 91       	pop	r23
 304:	6f 91       	pop	r22
 306:	5f 91       	pop	r21
 308:	4f 91       	pop	r20
 30a:	3f 91       	pop	r19
 30c:	2f 91       	pop	r18
 30e:	1f 91       	pop	r17
 310:	0f 91       	pop	r16
 312:	ff 90       	pop	r15
 314:	ef 90       	pop	r14
 316:	df 90       	pop	r13
 318:	cf 90       	pop	r12
 31a:	0f 90       	pop	r0
 31c:	0f be       	out	0x3f, r0	; 63
 31e:	0f 90       	pop	r0
 320:	1f 90       	pop	r1
 322:	18 95       	reti

00000324 <__vector_17>:

ISR(SPI_STC_vect)
{
 324:	1f 92       	push	r1
 326:	0f 92       	push	r0
 328:	0f b6       	in	r0, 0x3f	; 63
 32a:	0f 92       	push	r0
 32c:	11 24       	eor	r1, r1
 32e:	2f 93       	push	r18
 330:	8f 93       	push	r24
 332:	9f 93       	push	r25
 334:	ef 93       	push	r30
 336:	ff 93       	push	r31

	//Define local variables.
	unsigned char spi_byte;

	//Read in the SPI value.
	spi_byte = SPDR;
 338:	2e b5       	in	r18, 0x2e	; 46
	
	// Advance the spi index & ensure that it is in bounds.
	spi_index = (spi_index + 1) % NUM_SPI_BYTES;
 33a:	80 91 12 01 	lds	r24, 0x0112	; 0x800112 <__data_end>
 33e:	90 e0       	ldi	r25, 0x00	; 0
 340:	01 96       	adiw	r24, 0x01	; 1
 342:	81 70       	andi	r24, 0x01	; 1
 344:	90 78       	andi	r25, 0x80	; 128
 346:	99 23       	and	r25, r25
 348:	24 f4       	brge	.+8      	; 0x352 <__vector_17+0x2e>
 34a:	01 97       	sbiw	r24, 0x01	; 1
 34c:	8e 6f       	ori	r24, 0xFE	; 254
 34e:	9f 6f       	ori	r25, 0xFF	; 255
 350:	01 96       	adiw	r24, 0x01	; 1
 352:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <__data_end>
	
	// Set the spi data register to contain the next byte we want to send.
	SPDR = spi_bytes_to_send[spi_index];
 356:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <__data_end>
 35a:	f0 e0       	ldi	r31, 0x00	; 0
 35c:	ed 5e       	subi	r30, 0xED	; 237
 35e:	fe 4f       	sbci	r31, 0xFE	; 254
 360:	80 81       	ld	r24, Z
 362:	8e bd       	out	0x2e, r24	; 46
	
	//Cycle the SPI bytes.
	spi_bytes[0] = spi_bytes[1];
 364:	e5 e1       	ldi	r30, 0x15	; 21
 366:	f1 e0       	ldi	r31, 0x01	; 1
 368:	81 81       	ldd	r24, Z+1	; 0x01
 36a:	80 83       	st	Z, r24
	spi_bytes[1] = spi_byte;
 36c:	21 83       	std	Z+1, r18	; 0x01
	
	//Toggle Pin D4 to indicate complete SPI transfer.
	PORTD ^= (1 << 4);
 36e:	9b b1       	in	r25, 0x0b	; 11
 370:	80 e1       	ldi	r24, 0x10	; 16
 372:	89 27       	eor	r24, r25
 374:	8b b9       	out	0x0b, r24	; 11
	//PORTD |= (1 << 4);
	//PORTD &= ~(1 << 4);
	
	////Enable global interrupts.
	//sei();
}
 376:	ff 91       	pop	r31
 378:	ef 91       	pop	r30
 37a:	9f 91       	pop	r25
 37c:	8f 91       	pop	r24
 37e:	2f 91       	pop	r18
 380:	0f 90       	pop	r0
 382:	0f be       	out	0x3f, r0	; 63
 384:	0f 90       	pop	r0
 386:	1f 90       	pop	r1
 388:	18 95       	reti

0000038a <__subsf3>:
 38a:	50 58       	subi	r21, 0x80	; 128

0000038c <__addsf3>:
 38c:	bb 27       	eor	r27, r27
 38e:	aa 27       	eor	r26, r26
 390:	0e d0       	rcall	.+28     	; 0x3ae <__addsf3x>
 392:	31 c1       	rjmp	.+610    	; 0x5f6 <__fp_round>
 394:	22 d1       	rcall	.+580    	; 0x5da <__fp_pscA>
 396:	30 f0       	brcs	.+12     	; 0x3a4 <__addsf3+0x18>
 398:	27 d1       	rcall	.+590    	; 0x5e8 <__fp_pscB>
 39a:	20 f0       	brcs	.+8      	; 0x3a4 <__addsf3+0x18>
 39c:	31 f4       	brne	.+12     	; 0x3aa <__addsf3+0x1e>
 39e:	9f 3f       	cpi	r25, 0xFF	; 255
 3a0:	11 f4       	brne	.+4      	; 0x3a6 <__addsf3+0x1a>
 3a2:	1e f4       	brtc	.+6      	; 0x3aa <__addsf3+0x1e>
 3a4:	17 c1       	rjmp	.+558    	; 0x5d4 <__fp_nan>
 3a6:	0e f4       	brtc	.+2      	; 0x3aa <__addsf3+0x1e>
 3a8:	e0 95       	com	r30
 3aa:	e7 fb       	bst	r30, 7
 3ac:	e4 c0       	rjmp	.+456    	; 0x576 <__fp_inf>

000003ae <__addsf3x>:
 3ae:	e9 2f       	mov	r30, r25
 3b0:	33 d1       	rcall	.+614    	; 0x618 <__fp_split3>
 3b2:	80 f3       	brcs	.-32     	; 0x394 <__addsf3+0x8>
 3b4:	ba 17       	cp	r27, r26
 3b6:	62 07       	cpc	r22, r18
 3b8:	73 07       	cpc	r23, r19
 3ba:	84 07       	cpc	r24, r20
 3bc:	95 07       	cpc	r25, r21
 3be:	18 f0       	brcs	.+6      	; 0x3c6 <__addsf3x+0x18>
 3c0:	71 f4       	brne	.+28     	; 0x3de <__addsf3x+0x30>
 3c2:	9e f5       	brtc	.+102    	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
 3c4:	4b c1       	rjmp	.+662    	; 0x65c <__fp_zero>
 3c6:	0e f4       	brtc	.+2      	; 0x3ca <__addsf3x+0x1c>
 3c8:	e0 95       	com	r30
 3ca:	0b 2e       	mov	r0, r27
 3cc:	ba 2f       	mov	r27, r26
 3ce:	a0 2d       	mov	r26, r0
 3d0:	0b 01       	movw	r0, r22
 3d2:	b9 01       	movw	r22, r18
 3d4:	90 01       	movw	r18, r0
 3d6:	0c 01       	movw	r0, r24
 3d8:	ca 01       	movw	r24, r20
 3da:	a0 01       	movw	r20, r0
 3dc:	11 24       	eor	r1, r1
 3de:	ff 27       	eor	r31, r31
 3e0:	59 1b       	sub	r21, r25
 3e2:	99 f0       	breq	.+38     	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
 3e4:	59 3f       	cpi	r21, 0xF9	; 249
 3e6:	50 f4       	brcc	.+20     	; 0x3fc <__addsf3x+0x4e>
 3e8:	50 3e       	cpi	r21, 0xE0	; 224
 3ea:	68 f1       	brcs	.+90     	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
 3ec:	1a 16       	cp	r1, r26
 3ee:	f0 40       	sbci	r31, 0x00	; 0
 3f0:	a2 2f       	mov	r26, r18
 3f2:	23 2f       	mov	r18, r19
 3f4:	34 2f       	mov	r19, r20
 3f6:	44 27       	eor	r20, r20
 3f8:	58 5f       	subi	r21, 0xF8	; 248
 3fa:	f3 cf       	rjmp	.-26     	; 0x3e2 <__addsf3x+0x34>
 3fc:	46 95       	lsr	r20
 3fe:	37 95       	ror	r19
 400:	27 95       	ror	r18
 402:	a7 95       	ror	r26
 404:	f0 40       	sbci	r31, 0x00	; 0
 406:	53 95       	inc	r21
 408:	c9 f7       	brne	.-14     	; 0x3fc <__addsf3x+0x4e>
 40a:	7e f4       	brtc	.+30     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
 40c:	1f 16       	cp	r1, r31
 40e:	ba 0b       	sbc	r27, r26
 410:	62 0b       	sbc	r22, r18
 412:	73 0b       	sbc	r23, r19
 414:	84 0b       	sbc	r24, r20
 416:	ba f0       	brmi	.+46     	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
 418:	91 50       	subi	r25, 0x01	; 1
 41a:	a1 f0       	breq	.+40     	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
 41c:	ff 0f       	add	r31, r31
 41e:	bb 1f       	adc	r27, r27
 420:	66 1f       	adc	r22, r22
 422:	77 1f       	adc	r23, r23
 424:	88 1f       	adc	r24, r24
 426:	c2 f7       	brpl	.-16     	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
 428:	0e c0       	rjmp	.+28     	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
 42a:	ba 0f       	add	r27, r26
 42c:	62 1f       	adc	r22, r18
 42e:	73 1f       	adc	r23, r19
 430:	84 1f       	adc	r24, r20
 432:	48 f4       	brcc	.+18     	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
 434:	87 95       	ror	r24
 436:	77 95       	ror	r23
 438:	67 95       	ror	r22
 43a:	b7 95       	ror	r27
 43c:	f7 95       	ror	r31
 43e:	9e 3f       	cpi	r25, 0xFE	; 254
 440:	08 f0       	brcs	.+2      	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
 442:	b3 cf       	rjmp	.-154    	; 0x3aa <__addsf3+0x1e>
 444:	93 95       	inc	r25
 446:	88 0f       	add	r24, r24
 448:	08 f0       	brcs	.+2      	; 0x44c <__LOCK_REGION_LENGTH__+0x4c>
 44a:	99 27       	eor	r25, r25
 44c:	ee 0f       	add	r30, r30
 44e:	97 95       	ror	r25
 450:	87 95       	ror	r24
 452:	08 95       	ret

00000454 <__cmpsf2>:
 454:	6c d0       	rcall	.+216    	; 0x52e <__fp_cmp>
 456:	08 f4       	brcc	.+2      	; 0x45a <__cmpsf2+0x6>
 458:	81 e0       	ldi	r24, 0x01	; 1
 45a:	08 95       	ret

0000045c <__fixunssfsi>:
 45c:	e5 d0       	rcall	.+458    	; 0x628 <__fp_splitA>
 45e:	88 f0       	brcs	.+34     	; 0x482 <__fixunssfsi+0x26>
 460:	9f 57       	subi	r25, 0x7F	; 127
 462:	90 f0       	brcs	.+36     	; 0x488 <__fixunssfsi+0x2c>
 464:	b9 2f       	mov	r27, r25
 466:	99 27       	eor	r25, r25
 468:	b7 51       	subi	r27, 0x17	; 23
 46a:	a0 f0       	brcs	.+40     	; 0x494 <__fixunssfsi+0x38>
 46c:	d1 f0       	breq	.+52     	; 0x4a2 <__fixunssfsi+0x46>
 46e:	66 0f       	add	r22, r22
 470:	77 1f       	adc	r23, r23
 472:	88 1f       	adc	r24, r24
 474:	99 1f       	adc	r25, r25
 476:	1a f0       	brmi	.+6      	; 0x47e <__fixunssfsi+0x22>
 478:	ba 95       	dec	r27
 47a:	c9 f7       	brne	.-14     	; 0x46e <__fixunssfsi+0x12>
 47c:	12 c0       	rjmp	.+36     	; 0x4a2 <__fixunssfsi+0x46>
 47e:	b1 30       	cpi	r27, 0x01	; 1
 480:	81 f0       	breq	.+32     	; 0x4a2 <__fixunssfsi+0x46>
 482:	ec d0       	rcall	.+472    	; 0x65c <__fp_zero>
 484:	b1 e0       	ldi	r27, 0x01	; 1
 486:	08 95       	ret
 488:	e9 c0       	rjmp	.+466    	; 0x65c <__fp_zero>
 48a:	67 2f       	mov	r22, r23
 48c:	78 2f       	mov	r23, r24
 48e:	88 27       	eor	r24, r24
 490:	b8 5f       	subi	r27, 0xF8	; 248
 492:	39 f0       	breq	.+14     	; 0x4a2 <__fixunssfsi+0x46>
 494:	b9 3f       	cpi	r27, 0xF9	; 249
 496:	cc f3       	brlt	.-14     	; 0x48a <__fixunssfsi+0x2e>
 498:	86 95       	lsr	r24
 49a:	77 95       	ror	r23
 49c:	67 95       	ror	r22
 49e:	b3 95       	inc	r27
 4a0:	d9 f7       	brne	.-10     	; 0x498 <__fixunssfsi+0x3c>
 4a2:	3e f4       	brtc	.+14     	; 0x4b2 <__fixunssfsi+0x56>
 4a4:	90 95       	com	r25
 4a6:	80 95       	com	r24
 4a8:	70 95       	com	r23
 4aa:	61 95       	neg	r22
 4ac:	7f 4f       	sbci	r23, 0xFF	; 255
 4ae:	8f 4f       	sbci	r24, 0xFF	; 255
 4b0:	9f 4f       	sbci	r25, 0xFF	; 255
 4b2:	08 95       	ret

000004b4 <__floatunsisf>:
 4b4:	e8 94       	clt
 4b6:	09 c0       	rjmp	.+18     	; 0x4ca <__floatsisf+0x12>

000004b8 <__floatsisf>:
 4b8:	97 fb       	bst	r25, 7
 4ba:	3e f4       	brtc	.+14     	; 0x4ca <__floatsisf+0x12>
 4bc:	90 95       	com	r25
 4be:	80 95       	com	r24
 4c0:	70 95       	com	r23
 4c2:	61 95       	neg	r22
 4c4:	7f 4f       	sbci	r23, 0xFF	; 255
 4c6:	8f 4f       	sbci	r24, 0xFF	; 255
 4c8:	9f 4f       	sbci	r25, 0xFF	; 255
 4ca:	99 23       	and	r25, r25
 4cc:	a9 f0       	breq	.+42     	; 0x4f8 <__floatsisf+0x40>
 4ce:	f9 2f       	mov	r31, r25
 4d0:	96 e9       	ldi	r25, 0x96	; 150
 4d2:	bb 27       	eor	r27, r27
 4d4:	93 95       	inc	r25
 4d6:	f6 95       	lsr	r31
 4d8:	87 95       	ror	r24
 4da:	77 95       	ror	r23
 4dc:	67 95       	ror	r22
 4de:	b7 95       	ror	r27
 4e0:	f1 11       	cpse	r31, r1
 4e2:	f8 cf       	rjmp	.-16     	; 0x4d4 <__floatsisf+0x1c>
 4e4:	fa f4       	brpl	.+62     	; 0x524 <__stack+0x25>
 4e6:	bb 0f       	add	r27, r27
 4e8:	11 f4       	brne	.+4      	; 0x4ee <__floatsisf+0x36>
 4ea:	60 ff       	sbrs	r22, 0
 4ec:	1b c0       	rjmp	.+54     	; 0x524 <__stack+0x25>
 4ee:	6f 5f       	subi	r22, 0xFF	; 255
 4f0:	7f 4f       	sbci	r23, 0xFF	; 255
 4f2:	8f 4f       	sbci	r24, 0xFF	; 255
 4f4:	9f 4f       	sbci	r25, 0xFF	; 255
 4f6:	16 c0       	rjmp	.+44     	; 0x524 <__stack+0x25>
 4f8:	88 23       	and	r24, r24
 4fa:	11 f0       	breq	.+4      	; 0x500 <__stack+0x1>
 4fc:	96 e9       	ldi	r25, 0x96	; 150
 4fe:	11 c0       	rjmp	.+34     	; 0x522 <__stack+0x23>
 500:	77 23       	and	r23, r23
 502:	21 f0       	breq	.+8      	; 0x50c <__stack+0xd>
 504:	9e e8       	ldi	r25, 0x8E	; 142
 506:	87 2f       	mov	r24, r23
 508:	76 2f       	mov	r23, r22
 50a:	05 c0       	rjmp	.+10     	; 0x516 <__stack+0x17>
 50c:	66 23       	and	r22, r22
 50e:	71 f0       	breq	.+28     	; 0x52c <__stack+0x2d>
 510:	96 e8       	ldi	r25, 0x86	; 134
 512:	86 2f       	mov	r24, r22
 514:	70 e0       	ldi	r23, 0x00	; 0
 516:	60 e0       	ldi	r22, 0x00	; 0
 518:	2a f0       	brmi	.+10     	; 0x524 <__stack+0x25>
 51a:	9a 95       	dec	r25
 51c:	66 0f       	add	r22, r22
 51e:	77 1f       	adc	r23, r23
 520:	88 1f       	adc	r24, r24
 522:	da f7       	brpl	.-10     	; 0x51a <__stack+0x1b>
 524:	88 0f       	add	r24, r24
 526:	96 95       	lsr	r25
 528:	87 95       	ror	r24
 52a:	97 f9       	bld	r25, 7
 52c:	08 95       	ret

0000052e <__fp_cmp>:
 52e:	99 0f       	add	r25, r25
 530:	00 08       	sbc	r0, r0
 532:	55 0f       	add	r21, r21
 534:	aa 0b       	sbc	r26, r26
 536:	e0 e8       	ldi	r30, 0x80	; 128
 538:	fe ef       	ldi	r31, 0xFE	; 254
 53a:	16 16       	cp	r1, r22
 53c:	17 06       	cpc	r1, r23
 53e:	e8 07       	cpc	r30, r24
 540:	f9 07       	cpc	r31, r25
 542:	c0 f0       	brcs	.+48     	; 0x574 <__fp_cmp+0x46>
 544:	12 16       	cp	r1, r18
 546:	13 06       	cpc	r1, r19
 548:	e4 07       	cpc	r30, r20
 54a:	f5 07       	cpc	r31, r21
 54c:	98 f0       	brcs	.+38     	; 0x574 <__fp_cmp+0x46>
 54e:	62 1b       	sub	r22, r18
 550:	73 0b       	sbc	r23, r19
 552:	84 0b       	sbc	r24, r20
 554:	95 0b       	sbc	r25, r21
 556:	39 f4       	brne	.+14     	; 0x566 <__fp_cmp+0x38>
 558:	0a 26       	eor	r0, r26
 55a:	61 f0       	breq	.+24     	; 0x574 <__fp_cmp+0x46>
 55c:	23 2b       	or	r18, r19
 55e:	24 2b       	or	r18, r20
 560:	25 2b       	or	r18, r21
 562:	21 f4       	brne	.+8      	; 0x56c <__fp_cmp+0x3e>
 564:	08 95       	ret
 566:	0a 26       	eor	r0, r26
 568:	09 f4       	brne	.+2      	; 0x56c <__fp_cmp+0x3e>
 56a:	a1 40       	sbci	r26, 0x01	; 1
 56c:	a6 95       	lsr	r26
 56e:	8f ef       	ldi	r24, 0xFF	; 255
 570:	81 1d       	adc	r24, r1
 572:	81 1d       	adc	r24, r1
 574:	08 95       	ret

00000576 <__fp_inf>:
 576:	97 f9       	bld	r25, 7
 578:	9f 67       	ori	r25, 0x7F	; 127
 57a:	80 e8       	ldi	r24, 0x80	; 128
 57c:	70 e0       	ldi	r23, 0x00	; 0
 57e:	60 e0       	ldi	r22, 0x00	; 0
 580:	08 95       	ret

00000582 <__fp_mintl>:
 582:	88 23       	and	r24, r24
 584:	71 f4       	brne	.+28     	; 0x5a2 <__fp_mintl+0x20>
 586:	77 23       	and	r23, r23
 588:	21 f0       	breq	.+8      	; 0x592 <__fp_mintl+0x10>
 58a:	98 50       	subi	r25, 0x08	; 8
 58c:	87 2b       	or	r24, r23
 58e:	76 2f       	mov	r23, r22
 590:	07 c0       	rjmp	.+14     	; 0x5a0 <__fp_mintl+0x1e>
 592:	66 23       	and	r22, r22
 594:	11 f4       	brne	.+4      	; 0x59a <__fp_mintl+0x18>
 596:	99 27       	eor	r25, r25
 598:	0d c0       	rjmp	.+26     	; 0x5b4 <__fp_mintl+0x32>
 59a:	90 51       	subi	r25, 0x10	; 16
 59c:	86 2b       	or	r24, r22
 59e:	70 e0       	ldi	r23, 0x00	; 0
 5a0:	60 e0       	ldi	r22, 0x00	; 0
 5a2:	2a f0       	brmi	.+10     	; 0x5ae <__fp_mintl+0x2c>
 5a4:	9a 95       	dec	r25
 5a6:	66 0f       	add	r22, r22
 5a8:	77 1f       	adc	r23, r23
 5aa:	88 1f       	adc	r24, r24
 5ac:	da f7       	brpl	.-10     	; 0x5a4 <__fp_mintl+0x22>
 5ae:	88 0f       	add	r24, r24
 5b0:	96 95       	lsr	r25
 5b2:	87 95       	ror	r24
 5b4:	97 f9       	bld	r25, 7
 5b6:	08 95       	ret

000005b8 <__fp_mpack>:
 5b8:	9f 3f       	cpi	r25, 0xFF	; 255
 5ba:	31 f0       	breq	.+12     	; 0x5c8 <__fp_mpack_finite+0xc>

000005bc <__fp_mpack_finite>:
 5bc:	91 50       	subi	r25, 0x01	; 1
 5be:	20 f4       	brcc	.+8      	; 0x5c8 <__fp_mpack_finite+0xc>
 5c0:	87 95       	ror	r24
 5c2:	77 95       	ror	r23
 5c4:	67 95       	ror	r22
 5c6:	b7 95       	ror	r27
 5c8:	88 0f       	add	r24, r24
 5ca:	91 1d       	adc	r25, r1
 5cc:	96 95       	lsr	r25
 5ce:	87 95       	ror	r24
 5d0:	97 f9       	bld	r25, 7
 5d2:	08 95       	ret

000005d4 <__fp_nan>:
 5d4:	9f ef       	ldi	r25, 0xFF	; 255
 5d6:	80 ec       	ldi	r24, 0xC0	; 192
 5d8:	08 95       	ret

000005da <__fp_pscA>:
 5da:	00 24       	eor	r0, r0
 5dc:	0a 94       	dec	r0
 5de:	16 16       	cp	r1, r22
 5e0:	17 06       	cpc	r1, r23
 5e2:	18 06       	cpc	r1, r24
 5e4:	09 06       	cpc	r0, r25
 5e6:	08 95       	ret

000005e8 <__fp_pscB>:
 5e8:	00 24       	eor	r0, r0
 5ea:	0a 94       	dec	r0
 5ec:	12 16       	cp	r1, r18
 5ee:	13 06       	cpc	r1, r19
 5f0:	14 06       	cpc	r1, r20
 5f2:	05 06       	cpc	r0, r21
 5f4:	08 95       	ret

000005f6 <__fp_round>:
 5f6:	09 2e       	mov	r0, r25
 5f8:	03 94       	inc	r0
 5fa:	00 0c       	add	r0, r0
 5fc:	11 f4       	brne	.+4      	; 0x602 <__fp_round+0xc>
 5fe:	88 23       	and	r24, r24
 600:	52 f0       	brmi	.+20     	; 0x616 <__fp_round+0x20>
 602:	bb 0f       	add	r27, r27
 604:	40 f4       	brcc	.+16     	; 0x616 <__fp_round+0x20>
 606:	bf 2b       	or	r27, r31
 608:	11 f4       	brne	.+4      	; 0x60e <__fp_round+0x18>
 60a:	60 ff       	sbrs	r22, 0
 60c:	04 c0       	rjmp	.+8      	; 0x616 <__fp_round+0x20>
 60e:	6f 5f       	subi	r22, 0xFF	; 255
 610:	7f 4f       	sbci	r23, 0xFF	; 255
 612:	8f 4f       	sbci	r24, 0xFF	; 255
 614:	9f 4f       	sbci	r25, 0xFF	; 255
 616:	08 95       	ret

00000618 <__fp_split3>:
 618:	57 fd       	sbrc	r21, 7
 61a:	90 58       	subi	r25, 0x80	; 128
 61c:	44 0f       	add	r20, r20
 61e:	55 1f       	adc	r21, r21
 620:	59 f0       	breq	.+22     	; 0x638 <__fp_splitA+0x10>
 622:	5f 3f       	cpi	r21, 0xFF	; 255
 624:	71 f0       	breq	.+28     	; 0x642 <__fp_splitA+0x1a>
 626:	47 95       	ror	r20

00000628 <__fp_splitA>:
 628:	88 0f       	add	r24, r24
 62a:	97 fb       	bst	r25, 7
 62c:	99 1f       	adc	r25, r25
 62e:	61 f0       	breq	.+24     	; 0x648 <__fp_splitA+0x20>
 630:	9f 3f       	cpi	r25, 0xFF	; 255
 632:	79 f0       	breq	.+30     	; 0x652 <__fp_splitA+0x2a>
 634:	87 95       	ror	r24
 636:	08 95       	ret
 638:	12 16       	cp	r1, r18
 63a:	13 06       	cpc	r1, r19
 63c:	14 06       	cpc	r1, r20
 63e:	55 1f       	adc	r21, r21
 640:	f2 cf       	rjmp	.-28     	; 0x626 <__fp_split3+0xe>
 642:	46 95       	lsr	r20
 644:	f1 df       	rcall	.-30     	; 0x628 <__fp_splitA>
 646:	08 c0       	rjmp	.+16     	; 0x658 <__fp_splitA+0x30>
 648:	16 16       	cp	r1, r22
 64a:	17 06       	cpc	r1, r23
 64c:	18 06       	cpc	r1, r24
 64e:	99 1f       	adc	r25, r25
 650:	f1 cf       	rjmp	.-30     	; 0x634 <__fp_splitA+0xc>
 652:	86 95       	lsr	r24
 654:	71 05       	cpc	r23, r1
 656:	61 05       	cpc	r22, r1
 658:	08 94       	sec
 65a:	08 95       	ret

0000065c <__fp_zero>:
 65c:	e8 94       	clt

0000065e <__fp_szero>:
 65e:	bb 27       	eor	r27, r27
 660:	66 27       	eor	r22, r22
 662:	77 27       	eor	r23, r23
 664:	cb 01       	movw	r24, r22
 666:	97 f9       	bld	r25, 7
 668:	08 95       	ret

0000066a <__gesf2>:
 66a:	61 df       	rcall	.-318    	; 0x52e <__fp_cmp>
 66c:	08 f4       	brcc	.+2      	; 0x670 <__gesf2+0x6>
 66e:	8f ef       	ldi	r24, 0xFF	; 255
 670:	08 95       	ret

00000672 <__mulsf3>:
 672:	0b d0       	rcall	.+22     	; 0x68a <__mulsf3x>
 674:	c0 cf       	rjmp	.-128    	; 0x5f6 <__fp_round>
 676:	b1 df       	rcall	.-158    	; 0x5da <__fp_pscA>
 678:	28 f0       	brcs	.+10     	; 0x684 <__mulsf3+0x12>
 67a:	b6 df       	rcall	.-148    	; 0x5e8 <__fp_pscB>
 67c:	18 f0       	brcs	.+6      	; 0x684 <__mulsf3+0x12>
 67e:	95 23       	and	r25, r21
 680:	09 f0       	breq	.+2      	; 0x684 <__mulsf3+0x12>
 682:	79 cf       	rjmp	.-270    	; 0x576 <__fp_inf>
 684:	a7 cf       	rjmp	.-178    	; 0x5d4 <__fp_nan>
 686:	11 24       	eor	r1, r1
 688:	ea cf       	rjmp	.-44     	; 0x65e <__fp_szero>

0000068a <__mulsf3x>:
 68a:	c6 df       	rcall	.-116    	; 0x618 <__fp_split3>
 68c:	a0 f3       	brcs	.-24     	; 0x676 <__mulsf3+0x4>

0000068e <__mulsf3_pse>:
 68e:	95 9f       	mul	r25, r21
 690:	d1 f3       	breq	.-12     	; 0x686 <__mulsf3+0x14>
 692:	95 0f       	add	r25, r21
 694:	50 e0       	ldi	r21, 0x00	; 0
 696:	55 1f       	adc	r21, r21
 698:	62 9f       	mul	r22, r18
 69a:	f0 01       	movw	r30, r0
 69c:	72 9f       	mul	r23, r18
 69e:	bb 27       	eor	r27, r27
 6a0:	f0 0d       	add	r31, r0
 6a2:	b1 1d       	adc	r27, r1
 6a4:	63 9f       	mul	r22, r19
 6a6:	aa 27       	eor	r26, r26
 6a8:	f0 0d       	add	r31, r0
 6aa:	b1 1d       	adc	r27, r1
 6ac:	aa 1f       	adc	r26, r26
 6ae:	64 9f       	mul	r22, r20
 6b0:	66 27       	eor	r22, r22
 6b2:	b0 0d       	add	r27, r0
 6b4:	a1 1d       	adc	r26, r1
 6b6:	66 1f       	adc	r22, r22
 6b8:	82 9f       	mul	r24, r18
 6ba:	22 27       	eor	r18, r18
 6bc:	b0 0d       	add	r27, r0
 6be:	a1 1d       	adc	r26, r1
 6c0:	62 1f       	adc	r22, r18
 6c2:	73 9f       	mul	r23, r19
 6c4:	b0 0d       	add	r27, r0
 6c6:	a1 1d       	adc	r26, r1
 6c8:	62 1f       	adc	r22, r18
 6ca:	83 9f       	mul	r24, r19
 6cc:	a0 0d       	add	r26, r0
 6ce:	61 1d       	adc	r22, r1
 6d0:	22 1f       	adc	r18, r18
 6d2:	74 9f       	mul	r23, r20
 6d4:	33 27       	eor	r19, r19
 6d6:	a0 0d       	add	r26, r0
 6d8:	61 1d       	adc	r22, r1
 6da:	23 1f       	adc	r18, r19
 6dc:	84 9f       	mul	r24, r20
 6de:	60 0d       	add	r22, r0
 6e0:	21 1d       	adc	r18, r1
 6e2:	82 2f       	mov	r24, r18
 6e4:	76 2f       	mov	r23, r22
 6e6:	6a 2f       	mov	r22, r26
 6e8:	11 24       	eor	r1, r1
 6ea:	9f 57       	subi	r25, 0x7F	; 127
 6ec:	50 40       	sbci	r21, 0x00	; 0
 6ee:	8a f0       	brmi	.+34     	; 0x712 <__mulsf3_pse+0x84>
 6f0:	e1 f0       	breq	.+56     	; 0x72a <__mulsf3_pse+0x9c>
 6f2:	88 23       	and	r24, r24
 6f4:	4a f0       	brmi	.+18     	; 0x708 <__mulsf3_pse+0x7a>
 6f6:	ee 0f       	add	r30, r30
 6f8:	ff 1f       	adc	r31, r31
 6fa:	bb 1f       	adc	r27, r27
 6fc:	66 1f       	adc	r22, r22
 6fe:	77 1f       	adc	r23, r23
 700:	88 1f       	adc	r24, r24
 702:	91 50       	subi	r25, 0x01	; 1
 704:	50 40       	sbci	r21, 0x00	; 0
 706:	a9 f7       	brne	.-22     	; 0x6f2 <__mulsf3_pse+0x64>
 708:	9e 3f       	cpi	r25, 0xFE	; 254
 70a:	51 05       	cpc	r21, r1
 70c:	70 f0       	brcs	.+28     	; 0x72a <__mulsf3_pse+0x9c>
 70e:	33 cf       	rjmp	.-410    	; 0x576 <__fp_inf>
 710:	a6 cf       	rjmp	.-180    	; 0x65e <__fp_szero>
 712:	5f 3f       	cpi	r21, 0xFF	; 255
 714:	ec f3       	brlt	.-6      	; 0x710 <__mulsf3_pse+0x82>
 716:	98 3e       	cpi	r25, 0xE8	; 232
 718:	dc f3       	brlt	.-10     	; 0x710 <__mulsf3_pse+0x82>
 71a:	86 95       	lsr	r24
 71c:	77 95       	ror	r23
 71e:	67 95       	ror	r22
 720:	b7 95       	ror	r27
 722:	f7 95       	ror	r31
 724:	e7 95       	ror	r30
 726:	9f 5f       	subi	r25, 0xFF	; 255
 728:	c1 f7       	brne	.-16     	; 0x71a <__mulsf3_pse+0x8c>
 72a:	fe 2b       	or	r31, r30
 72c:	88 0f       	add	r24, r24
 72e:	91 1d       	adc	r25, r1
 730:	96 95       	lsr	r25
 732:	87 95       	ror	r24
 734:	97 f9       	bld	r25, 7
 736:	08 95       	ret

00000738 <round>:
 738:	77 df       	rcall	.-274    	; 0x628 <__fp_splitA>
 73a:	e0 f0       	brcs	.+56     	; 0x774 <round+0x3c>
 73c:	9e 37       	cpi	r25, 0x7E	; 126
 73e:	d8 f0       	brcs	.+54     	; 0x776 <round+0x3e>
 740:	96 39       	cpi	r25, 0x96	; 150
 742:	b8 f4       	brcc	.+46     	; 0x772 <round+0x3a>
 744:	9e 38       	cpi	r25, 0x8E	; 142
 746:	48 f4       	brcc	.+18     	; 0x75a <round+0x22>
 748:	67 2f       	mov	r22, r23
 74a:	78 2f       	mov	r23, r24
 74c:	88 27       	eor	r24, r24
 74e:	98 5f       	subi	r25, 0xF8	; 248
 750:	f9 cf       	rjmp	.-14     	; 0x744 <round+0xc>
 752:	86 95       	lsr	r24
 754:	77 95       	ror	r23
 756:	67 95       	ror	r22
 758:	93 95       	inc	r25
 75a:	95 39       	cpi	r25, 0x95	; 149
 75c:	d0 f3       	brcs	.-12     	; 0x752 <round+0x1a>
 75e:	b6 2f       	mov	r27, r22
 760:	b1 70       	andi	r27, 0x01	; 1
 762:	6b 0f       	add	r22, r27
 764:	71 1d       	adc	r23, r1
 766:	81 1d       	adc	r24, r1
 768:	20 f4       	brcc	.+8      	; 0x772 <round+0x3a>
 76a:	87 95       	ror	r24
 76c:	77 95       	ror	r23
 76e:	67 95       	ror	r22
 770:	93 95       	inc	r25
 772:	07 cf       	rjmp	.-498    	; 0x582 <__fp_mintl>
 774:	21 cf       	rjmp	.-446    	; 0x5b8 <__fp_mpack>
 776:	73 cf       	rjmp	.-282    	; 0x65e <__fp_szero>

00000778 <_exit>:
 778:	f8 94       	cli

0000077a <__stop_program>:
 77a:	ff cf       	rjmp	.-2      	; 0x77a <__stop_program>
